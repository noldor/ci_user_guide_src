################
ライブラリの作成
################

私たちが用語「ライブラリ」を使用するとき、
基本的にライブラリディレクトリにあるクラス、
このユーザガイドのクラスリファレンスで説明されているクラスを指しています。
しかしながらここにおいてはそれではなく、
application/libraries ディレクトリ内に独自のライブラリを作成する方法について説明します。
ローカルリソースとグローバルなフレームワークリソースを分離、維持するためにの方法です。

おまけとして、 CodeIgniter はあなたのライブラリでネイティブクラスを継承することを可能にします。
既存のライブラリに単純にいくつかの機能を追加する必要がある場合です。
さらには
*application/libraries* に同じ名前の独自バージョンを置くことによって、ネイティブライブラリを置き換えることさえできます。

要約すれば:

-  あなたは完全に新しいライブラリを作成することができます。
-  あなたはネイティブライブラリを継承することができます。
-  あなたはネイティブライブラリを置き換えることができます。

このページでは、以下にこれら 3 つの概念について詳細に説明します。

.. note:: データベースクラスを継承したり、独自のクラスに置き換えることはできません。
	他のすべてのクラスは継承/交換することができます。

保存場所
========

あなたのライブラリクラスは *application/libraries*
ディレクトリ内に配置する必要があります、 それらが初期化されるときに CodeIgniter
が検索する場所だからです。

命名規則
========

-  ファイル名の 1 文字目は大文字でなければなりません。たとえば: Myclass.php
-  クラス宣言の 1 文字目は大文字でなければなりません。たとえば: class Myclass
-  クラス名とファイル名が一致している必要があります。

クラスファイル
==============

クラスにはこの基本的なプロトタイプが必要です::

	<?php
	defined('BASEPATH') OR exit('No direct script access allowed'); 

	class Someclass {

		public function some_method()
		{
		}
	}

.. note:: ここでは純粋に例として Someclass という名前を使用しています。

あなたのクラスの利用
====================

:doc:`コントローラ <controllers>` メソッドのどこででも、
標準の方法を使用してクラスを初期化することができます::

	$this->load->library('someclass');

*someclass* の箇所はファイル名で、「 .php 」のファイル拡張子は不要です。
ファイル名の 1 文字目は大文字でも小文字でも使えます。CodeIgniter
は気にしません。

一度ロードすれば、1文字目を小文字にしたものであなたのクラスにアクセスすることができます::

	$this->someclass->some_method();  // Object インスタンスは常に小文字になります

クラスの初期化時にパラメータを渡す
==================================

ライブラリのロードメソッドでは動的にデータを配列として
第 2 引数で渡すことができ、
それはクラスのコンストラクタで渡されます::

	$params = array('type' => 'large', 'color' => 'red');

	$this->load->library('someclass', $params);

この機能を使用する場合は、クラスのコンストラクタでデータを要求するよう
セットアップする必要があります::

	<?php defined('BASEPATH') OR exit('No direct script access allowed');

	class Someclass {

		public function __construct($params)
		{
			// $params で何かをする
		}
	}

また、設定ファイルに保存されたパラメータを渡すこともできます。
単純にクラスファイル名と同じ名前の設定ファイルを作成し、
*application/config/* ディレクトリに保存します。
前述の方法で動的にパラメータを渡す場合、
設定ファイルのオプションは使用できませんので注意してください。

ライブラリ内で CodeIgniter のリソースを利用する
===============================================

あなたのライブラリ内で CodeIgniter のネイティブリソースにアクセスするには
``get_instance()`` メソッドを使用します。このメソッドは CodeIgniter
のスーパーオブジェクトを返します。

通常、コントローラメソッド内では
``$this`` 構造を使用して、 CodeIgniter メソッドの利用可能なうちのいずれかを呼び出しています::

	$this->load->helper('url');
	$this->load->library('session');
	$this->config->item('base_url');
	// など。

しかしながら ``$this`` はこれはコントローラ内、
モデル内、ビュー内で直接使用する場合にだけ動作します。独自のカスタムクラス内から CodeIgniter
のクラスを使用したい場合は、以下のようにできます:

まず、変数に CodeIgniter のオブジェクトを割り当てます::

	$CI =& get_instance();

オブジェクトを変数に割り当てたなら、
``$this`` の *かわりに* その変数を使用します::

	$CI =& get_instance();

	$CI->load->helper('url');
	$CI->load->library('session');
	$CI->config->item('base_url');
	// など。

.. note:: 上記 ``get_instance()`` 関数は、
	参照によって渡されていることがわかるでしょう::
	
		$CI =& get_instance();

	これは非常に重要です。参照による割り当てにより、そのコピーを作成するのではなく、
	オリジナルの CodeIgniter オブジェクトを使用することができます。

しかしながら、ライブラリはクラスであるので、 OOP の原則を十分に活用したいなら、
そうするのが良いでしょう。つまり、クラスメソッドのすべてで
CodeIgniter のスーパーオブジェクトを使用できるようにするために、
上記例のかわりにプロパティに割り当てることをおすすめします::

	class Example_library {

		protected $CI;

        // コンストラクタを使いましょう、プロパティの定義部では
        // 直接関数を呼ぶことはできませんので。
		public function __construct()
		{
			// CodeIgniter のスーパーオブジェクトを割り当てる
			$this->CI =& get_instance();
		}

		public function foo()
		{
			$this->CI->load->helper('url');
			redirect();
		}

		public function bar()
		{
			echo $this->CI->config->item('base_url');
		}

	}

独自バージョンでネイティブライブラリを置き換える
================================================

単純に、ネイティブライブラリと同一のクラスファイル名をつけることにより、
CodeIgniter はネイティブライブラリのかわりにそれを使用するようになります。
この機能を使用するには、ファイル名とクラス名を
ネイティブライブラリのものと正確に同じにする必要があります。たとえば、ネイティブのメール Email
ライブラリを置き換えるためには、 *application/libraries/Email.php* という名前のファイルを作成し、
つぎのようにクラスを宣言します::

	class CI_Email {
	
	}

ほとんどのネイティブクラスはプレフィックス CI\_ がついていることに注意してください。

独自のライブラリをロードするには、標準の読み込み方法でできます::

	$this->load->library('email');

.. note:: この方法では、データベースクラスは
	独自のバージョンに置き換えることはできません。

ネイティブライブラリを継承する
==============================

やりたいことがいくらかの機能を既存のライブラリに加えたいだけ――
ひょっとするとメソッドをひとつふたつ追加する場合――、ライブラリ全体を
あなたのバージョンに置き換えるのはやりすぎです。この場合、
シンプルにクラスを継承するのが良いでしょう。クラスを継承するのは 2 つの例外を除いて、
クラスを置き換えるとほぼ同じです:

-  クラスは、親クラスを継承する必要があります。
-  新しいクラス名とファイル名は、プレフィックスに MY\_ を付ける必要があります (これは
   設定で変更可能です。後述します) 。

たとえば、ネイティブのEmailクラスを拡張するためには、
*application/libraries/MY_Email.php* という名前のファイルを作成し、つぎのようにクラスを宣言します::

	class MY_Email extends CI_Email {

	}

クラスのコンストラクタを使用する必要がある場合、
親クラスのコンストラクタを呼び出していることを確認してください::

	class MY_Email extends CI_Email {

		public function __construct($config = array())
		{
			parent::__construct($config);
		}

	}

.. note:: すべてのライブラリでコンストラクタが同じ (または任意の) パラメータが
	あるわけではありません。それを実装する方法を確認するため、
	まずは継承するライブラリを見てみてください。

サブクラスをロードする
----------------------

サブクラスをロードするには、通常使用されている標準的な構文を使用します。
プレフィックスを　つ　け　な　い　で　ください。たとえば、上記の例、
Email クラスを拡張継承したものをロードするには次のようにします::

	$this->load->library('email');

一度ロードすれば、継承元クラスを普通に使う場合と同じように、
クラス変数を使用します。Emailクラスの場合、
すべての呼び出しが次のようになります::

	$this->email->some_method();

独自のプレフィックスを設定する
------------------------------

サブクラスに独自のプレフィックスを設定するには
*application/config/config.php* ファイルを開いて、次の項目を探してください::

	$config['subclass_prefix'] = 'MY_';

すべての標準の CodeIgniter のライブラリはプレフィックスに CI\_
がついていますので、これは　使　わ　な　い　よ　う　ご注意ください。